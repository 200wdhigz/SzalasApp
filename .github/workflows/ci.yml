name: CI / Release / Docker

on:
  push:
    branches: [ "master" ]
  workflow_dispatch:

# Default: least privilege. Jobs override when needed.
permissions:
  contents: read

# Avoid duplicated runs per-branch and per-PR.
concurrency:
  group: ci-${{ github.workflow }}-${{ github.event_name }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # 2) Create a stable GitHub release when app/pyproject.toml version is bumped to a new value
  release_on_version_bump:
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest

    permissions:
      contents: write

    outputs:
      created: ${{ steps.should_release.outputs.create }}
      tag: ${{ steps.compute.outputs.tag }}

    steps:
      - name: Check out the repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute version/tag from app/pyproject.toml
        id: compute
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import re
          from pathlib import Path

          data = Path('app/pyproject.toml').read_text(encoding='utf-8')
          m = re.search(r'^version\s*=\s*"([^"]+)"', data, re.M)
          if not m:
              raise SystemExit('Could not find version in app/pyproject.toml')
          version = m.group(1).strip()
          tag = f"v{version}"

          # GitHub Actions: write outputs to the file path stored in $GITHUB_OUTPUT
          out = Path.cwd() / 'GITHUB_OUTPUT'
          with out.open('a', encoding='utf-8') as f:
              f.write(f"version={version}\n")
              f.write(f"tag={tag}\n")

          print(f"Computed version={version}, tag={tag}")
          PY

      - name: Decide if this is a new version
        id: should_release
        shell: bash
        run: |
          set -euo pipefail
          TAG='${{ steps.compute.outputs.tag }}'
          if [ -z "$TAG" ]; then
            echo "Computed TAG is empty - failing early."
            exit 1
          fi
          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            echo "create=false" >> "$GITHUB_OUTPUT"
            echo "Tag ${TAG} already exists - skipping release."
          else
            echo "create=true" >> "$GITHUB_OUTPUT"
            echo "Tag ${TAG} does not exist - will create release."
          fi

      - name: Determine previous version tag
        if: steps.should_release.outputs.create == 'true'
        id: prev
        shell: bash
        run: |
          set -euo pipefail
          PREV=$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-version:refname | head -n 1 || true)
          echo "previous=$PREV" >> "$GITHUB_OUTPUT"

      - name: Generate release notes (inline)
        if: steps.should_release.outputs.create == 'true'
        env:
          OWNER_REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_TAG: ${{ steps.compute.outputs.tag }}
          PREVIOUS_TAG: ${{ steps.prev.outputs.previous }}
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${RELEASE_TAG}" ]; then
            echo "RELEASE_TAG is empty - failing early."
            exit 1
          fi

          echo "${RELEASE_TAG}" > payload.md
          echo "" >> payload.md
          echo "## What's Changed" >> payload.md

          CUTOFF="1970-01-01"
          if [ -n "${PREVIOUS_TAG:-}" ]; then
            CUTOFF=$(git show -s --format=%cs "${PREVIOUS_TAG}" || echo "1970-01-01")
          fi

          # Query merged PRs since cutoff. We keep it simple and URL-encode via python argv (no env needed).
          Q="repo:${OWNER_REPO} is:pr is:merged merged:>${CUTOFF}"
          ENC_Q=$(python -c 'import sys,urllib.parse; print(urllib.parse.quote(sys.argv[1]))' "$Q")
          URL="https://api.github.com/search/issues?q=${ENC_Q}"

          API_JSON=$(curl -sS -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" "$URL" || true)
          PR_COUNT=$(echo "$API_JSON" | jq -r '.items | length' 2>/dev/null || echo 0)

          if [ "$PR_COUNT" -gt 0 ]; then
            echo "$API_JSON" | jq -r '.items[] | "- \(.title) by @\(.user.login) in #\(.number)"' >> payload.md

            echo "" >> payload.md
            echo "## New Contributors" >> payload.md
            echo "$API_JSON" | jq -r '.items[].user.login' | sort -fu | sed 's/^/- @/' >> payload.md
          else
            if [ -n "${PREVIOUS_TAG:-}" ]; then
              git log --pretty=format:'- %s' "${PREVIOUS_TAG}..HEAD" | head -n 50 >> payload.md
            else
              git log --pretty=format:'- %s' HEAD | head -n 50 >> payload.md
            fi
          fi

          echo "" >> payload.md
          echo "## Full Changelog" >> payload.md
          if [ -n "${PREVIOUS_TAG:-}" ]; then
            echo "https://github.com/${OWNER_REPO}/compare/${PREVIOUS_TAG}...${RELEASE_TAG}" >> payload.md
          else
            echo "https://github.com/${OWNER_REPO}/commits/${RELEASE_TAG}" >> payload.md
          fi

      - name: Create Git tag
        if: steps.should_release.outputs.create == 'true'
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "${{ steps.compute.outputs.tag }}"
          git push origin "${{ steps.compute.outputs.tag }}"

      - name: Create GitHub Release
        if: steps.should_release.outputs.create == 'true'
        uses: softprops/action-gh-release@v2
        with:
          draft: false
          prerelease: false
          tag_name: ${{ steps.compute.outputs.tag }}
          name: ${{ steps.compute.outputs.tag }}
          body_path: payload.md

  # 3) Build and push Docker image on push to master
  docker_build_push:
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest

    # Needs DOCKERHUB_* secrets; no write permissions required.
    permissions:
      contents: read

    steps:
      - name: Check out the repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to dockerhub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Detect release tag on current commit
        id: rel
        run: |
          TAG=$(git tag --points-at HEAD | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -n 1 || true)
          if [ -n "$TAG" ]; then
            echo "is_release=true" >> $GITHUB_OUTPUT
            echo "version_tag=$TAG" >> $GITHUB_OUTPUT
            echo "Detected release tag: $TAG"
          else
            echo "is_release=false" >> $GITHUB_OUTPUT
            echo "No release tag on this commit."
          fi

      - name: Extract Docker metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: filiprar/szalasapp
          tags: |
            type=raw,value=edge
            type=sha,format=short,prefix=sha-

      - name: Compose final tag list
        id: tags
        run: |
          TAGS="${{ steps.meta.outputs.tags }}"

          if [ "${{ steps.rel.outputs.is_release }}" = "true" ]; then
            TAGS="$TAGS,filiprar/szalasapp:${{ steps.rel.outputs.version_tag }},filiprar/szalasapp:latest"
          fi

          echo "$TAGS" | tr ',' '\n' > tags.txt
          echo "tags<<EOF" >> $GITHUB_OUTPUT
          cat tags.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.tags.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

